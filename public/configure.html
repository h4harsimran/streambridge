<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>StreamBridge • Emby/Jellyfin ↔ Stremio Setup</title>

<!-- ----------  Design tokens  ---------- -->
<style>
:root{
  --bg:      #11181f;
  --panel:   #1b2530;
  --accent:  #22c55e;           /* green-500 */
  --accent-d:#16a34a;           /* darker hover */
  --text:    #e6e9ef;
  --text-dim:#9aa3b5;
  --radius:  14px;
  --shadow:  0 6px 24px rgba(0,0,0,.25);
  --gap:     1.0rem;
  font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,sans-serif;
  line-height:1.4;
  color-scheme: dark;
}
*,*:before,*:after{box-sizing:border-box}
body{
  margin:0;min-height:100vh;background:var(--bg);color:var(--text);
  display:flex;align-items:center;justify-content:center;padding:2rem 1rem;
}

h1{margin:.5rem 0 0.5rem;text-align:center;font-size:1.6rem;font-weight:600}
h2{margin:2rem 0 .75rem;font-size:1.15rem;font-weight:600;color:var(--text-dim)}
h3{margin:1.5rem 0 .75rem;font-size:1rem;font-weight:600;color:var(--text-dim)}
small{font-size:.8rem;color:var(--text-dim)}
a{color:var(--accent);text-decoration:none}
a:hover{text-decoration:underline}

/* Visual grouping and separation */
.section-divider{
  height:1px;background:linear-gradient(to right,transparent,#283141 20%,#283141 80%,transparent);
  margin:2.5rem 0 1.5rem;border:none;
}
.form-group{
  background:#162029;border:1px solid #1f2a35;border-radius:10px;
  padding:1.25rem;margin-bottom:1rem;
}
.form-group form{display:flex;flex-direction:column;gap:0}
.form-group button{margin-top:0.75rem}
.advanced-group{
  background:#162029;border:1px solid #1f2a35;border-radius:10px;
  padding:1.25rem;margin-top:0;
}
.advanced-group h3{margin-top:0;margin-bottom:1.25rem;padding-bottom:0.75rem;border-bottom:1px solid #1f2a35}
.field-group{margin-bottom:1.25rem}
.field-group:last-child{margin-bottom:0}
/* Standard label styling - all labels in field-group */
.field-group > label{font-weight:500;color:var(--text)}
/* Regular labels (not flex/checkbox) */
.field-group > label:not([style*="display:flex"]){margin-bottom:0.4rem;margin-top:0}
.field-group > label:not([style*="display:flex"]) + input{margin-top:0}
/* Labels with descriptions - small text appears right after label */
.field-group > label + small{margin-top:-0.15rem;margin-bottom:0.5rem}
.field-group > label + small + input{margin-top:0}
/* Checkbox labels (flex containers with inline checkbox) */
.field-group > label[style*="display:flex"]{margin-bottom:0.5rem;margin-top:0;font-weight:normal}
/* Small text after checkbox labels */
.field-group > label[style*="display:flex"] + small{margin-top:0;margin-bottom:0}
.form-output{
  background:#162029;border:1px solid #1f2a35;border-radius:10px;
  padding:1.25rem;margin-top:1rem;
}

.panel{
  background:var(--panel);padding:2rem;border-radius:var(--radius);
  width:100%;max-width:600px;box-shadow:var(--shadow);
}
form{display:flex;flex-direction:column;gap:0}
label{font-size:.9rem;display:block;font-weight:500;color:var(--text)}
small{font-size:.8rem;color:var(--text-dim);line-height:1.4;display:block}
input{
  width:100%;padding:.65rem .8rem;border-radius:8px;border:1px solid #334155;
  background:#0f1722;color:var(--text);font-size:.95rem;
}
input:focus{outline:2px solid var(--accent);outline-offset:0}
input[type="checkbox"]{width:auto;margin:0 .5rem 0 0;cursor:pointer}
form#cfg{display:flex;flex-direction:column;gap:0}
form#cfg > *{width:100%}
button{
  display:inline-flex;align-items:center;justify-content:center;
  gap:.45rem;padding:.75rem 1rem;font-weight:600;font-size:.96rem;
  border:0;border-radius:8px;background:var(--accent);color:#fff;cursor:pointer;
  transition:.18s transform,.18s background;width:100%;
}
button:hover{background:var(--accent-d);transform:translateY(-1px)}
button:disabled{opacity:.45;cursor:default;transform:none}

pre{
  background:#0f1722;border:1px solid #283141;color:#e2e8f0;
  padding:.9rem;border-radius:8px;white-space:pre-wrap;word-break:break-all;
  margin:0;
}
.out{margin-top:1rem;animation:fade .35s ease}
@keyframes fade{from{opacity:0;transform:translateY(4px)}to{opacity:1}}
.toast{
  position:fixed;bottom:1.1rem;left:50%;transform:translateX(-50%);
  background:#272e38;padding:.7rem 1.4rem;border-radius:8px;
  box-shadow:var(--shadow);font-size:.9rem;opacity:0;pointer-events:none;
  transition:opacity .25s ease;
}
.toast.show{opacity:1}

/* Server Type Selection Cards */
.server-selection {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 1rem;
  margin-bottom: 1.5rem;
}
.server-card {
  background: #162029;
  border: 2px solid #1f2a35;
  border-radius: 12px;
  padding: 1.5rem;
  cursor: pointer;
  transition: all 0.2s ease;
  text-align: center;
  position: relative;
}
.server-card:hover {
  border-color: #334155;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
}
.server-card.selected {
  border-color: var(--accent);
  background: #1a2e1f;
  box-shadow: 0 0 0 3px rgba(34,197,94,0.1);
}
.server-card.selected::after {
  content: "✓";
  position: absolute;
  top: 0.5rem;
  right: 0.5rem;
  width: 24px;
  height: 24px;
  background: var(--accent);
  color: #fff;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.875rem;
  font-weight: bold;
}
.server-card-name {
  font-size: 1.25rem;
  font-weight: 600;
  color: var(--text);
  margin-bottom: 0.25rem;
}
.server-card-desc {
  font-size: 0.85rem;
  color: var(--text-dim);
}

@media (max-width: 640px) {
  .server-selection {
    grid-template-columns: 1fr;
  }
}

iframe.floatingchat-container,
iframe[id*="kofi-wo-container"] {
  width: 180px !important;      /* Match button's max width */
  height: 46px !important;      /* Match button's height */
  border-radius: 100px !important; /* Make pill-shaped like button */
  overflow: hidden;
  background: transparent !important;
  border: none !important;
  box-shadow: none !important;
}
</style>
</head>
<body>

<div class="panel">
  <h1>StreamBridge Setup</h1>
  <p style="text-align:center;margin-top:0.5rem;font-size:.8rem;color:var(--text-dim)">
    Stream from your Emby or Jellyfin server to Stremio<br>
    Need help? See <a href="https://github.com/h4harsimran/streambridge" target="_blank">docs on GitHub</a>.
  </p>
  
  <!-- HTTPS Warning -->
  <div style="background:#1e293b;border:1px solid #475569;border-radius:8px;padding:1rem;margin-bottom:1.5rem;">
    <div style="display:flex;align-items:center;gap:0.5rem;margin-bottom:0.5rem;">
      <span style="color:#fbbf24;font-size:1.2rem;">⚠️</span>
      <strong style="color:#fbbf24;">Important: HTTPS Required</strong>
    </div>
    <p style="margin:0;font-size:0.9rem;color:var(--text-dim);line-height:1.4;">
      This addon only works with Emby or Jellyfin servers accessible via <strong>HTTPS</strong>. 
      HTTP and localhost addresses are not supported. Make sure your server is accessible 
      through a secure HTTPS connection.
    </p>
  </div>

  <!--  1· Server Type Selection  -->
  <h2>1 · Select Server Type</h2>
  <div style="margin-bottom:1.5rem;">
    <div class="server-selection">
      <div class="server-card emby" data-server-type="emby" id="serverCardEmby">
        <div class="server-card-name">Emby</div>
      </div>
      <div class="server-card jellyfin" data-server-type="jellyfin" id="serverCardJellyfin">
        <div class="server-card-name">Jellyfin</div>
      </div>
    </div>
    <!-- Hidden input to store selected server type -->
    <input type="hidden" id="selectedServerType" value="emby">
  </div>

  <!--  2· Helper  -->
  <h2>2 · Fetch User ID & Token</h2>
  <div class="form-group">
    <form id="helper">
      <div class="field-group">
        <label>Server URL</label>
        <input name="url" placeholder="https://example.com:8096" required>
      </div>
      <div class="field-group">
        <label>Server Username</label>
        <input name="user" placeholder="Your server username" required>
      </div>
      <div class="field-group">
        <label>Server Password</label>
        <input name="pass" type="password" placeholder="Your server password">
      </div>
      <button id="helperBtn">Get Access Info</button>
    </form>
  </div>

  <div id="helperOut" class="out form-output" style="display:none">
    <small>User ID</small><pre id="uid"></pre>
    <small style="margin-top:.6rem;display:block">Access Token</small><pre id="tok"></pre>
  </div>

  <!--  3· Configure  -->
  <hr class="section-divider">
  <h2>3 · Generate Install Link</h2>
  <form id="cfg">
    <div class="form-group">
      <!-- Hidden input to store server type from selection -->
      <input type="hidden" name="serverType" id="cfgServerType" value="emby">
      <div class="field-group">
        <label>Server URL</label>
        <input name="serverUrl" required>
      </div>
      <div class="field-group">
        <label>User ID</label>
        <input name="userId" required>
      </div>
      <div class="field-group">
        <label>Access Token / API Key</label>
        <input name="accessToken" required>
      </div>
    </div>
    
    <!-- New configuration options -->
    <div class="advanced-group">
      <h3>Advanced Options</h3>
      
      <div class="field-group">
        <label style="display:flex;align-items:center;gap:0.5rem;cursor:pointer;margin:0;">
          <input type="checkbox" name="showServerName">
          <span>Show server name in addon name</span>
        </label>
        <small>Better to keep it unchecked for privacy unless you are installing multiple instances of this addon</small>
      </div>
      
      <div class="field-group">
        <label class="description-after">Stream Name (displayed in Stremio)</label>
        <small id="streamNameHint">Custom name for streams (defaults to "Emby")</small>
        <input name="streamName" id="streamNameInput" placeholder="Emby" value="">
      </div>
      
      <div class="field-group">
        <label class="description-after">Hide Stream Types</label>
        <small>Check types to hide from results</small>
        <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:0.6rem;margin-top:0.5rem;">
          <label style="display:flex;align-items:center;gap:0.5rem;cursor:pointer;font-weight:normal;margin:0;">
            <input type="checkbox" name="hideStreamTypes" value="4K">
            <span>4K</span>
          </label>
          <label style="display:flex;align-items:center;gap:0.5rem;cursor:pointer;font-weight:normal;margin:0;">
            <input type="checkbox" name="hideStreamTypes" value="1080p">
            <span>1080p</span>
          </label>
          <label style="display:flex;align-items:center;gap:0.5rem;cursor:pointer;font-weight:normal;margin:0;">
            <input type="checkbox" name="hideStreamTypes" value="DV">
            <span>Dolby Vision (DV)</span>
          </label>
          <label style="display:flex;align-items:center;gap:0.5rem;cursor:pointer;font-weight:normal;margin:0;">
            <input type="checkbox" name="hideStreamTypes" value="HDR">
            <span>All HDR</span>
          </label>
        </div>
      </div>
    </div>
    
    <button id="cfgBtn" style="margin-top:1rem">Create & Install Addon</button>
  </form>

  <div id="cfgOut" class="out form-output"></div>

</div>

<!-- ---------- Toast ---------- -->
<div id="toast" class="toast">Copied!</div>

<!-- ----------  Scripts  ---------- -->
<script>
const $ = sel=>document.querySelector(sel);
const toast = msg =>{
  const t=$("#toast");t.textContent=msg;t.classList.add("show");
  setTimeout(()=>t.classList.remove("show"),2200);
};

// Function to sync server type throughout the form
function syncServerType(serverType) {
  const selectedServerType = $("#selectedServerType");
  const cfgServerType = $("#cfgServerType");
  const streamNameInput = $("#streamNameInput");
  const streamNameHint = $("#streamNameHint");
  const embyCard = $("#serverCardEmby");
  const jellyfinCard = $("#serverCardJellyfin");
  
  // Update hidden inputs
  if (selectedServerType) {
    selectedServerType.value = serverType || "emby";
  }
  if (cfgServerType) {
    cfgServerType.value = serverType || "emby";
  }
  
  // Update card selection visual state
  if (embyCard && jellyfinCard) {
    if (serverType === "jellyfin") {
      embyCard.classList.remove("selected");
      jellyfinCard.classList.add("selected");
    } else {
      embyCard.classList.add("selected");
      jellyfinCard.classList.remove("selected");
    }
  }
  
  // Update stream name placeholder and hint based on server type
  if (streamNameInput && streamNameHint) {
    const defaultName = serverType === "jellyfin" ? "Jellyfin" : "Emby";
    const currentValue = streamNameInput.value.trim();
    
    // Update placeholder
    streamNameInput.placeholder = defaultName;
    
    // Only auto-update the value if it's empty or matches the old default
    // Don't overwrite custom values
    if (!currentValue || currentValue === "Emby" || currentValue === "Jellyfin") {
      // Only clear if it was the opposite default (e.g., had "Emby" but switched to Jellyfin)
      // If empty, leave it empty so user can see the placeholder
      if (currentValue && currentValue !== defaultName) {
        streamNameInput.value = "";
      }
    }
    
    streamNameHint.textContent = `Custom name for streams (defaults to "${defaultName}")`;
  }
}

// Server card selection handlers
const embyCardEl = $("#serverCardEmby");
const jellyfinCardEl = $("#serverCardJellyfin");

if (embyCardEl) {
  embyCardEl.addEventListener("click", ()=>{
    syncServerType("emby");
  });
}
if (jellyfinCardEl) {
  jellyfinCardEl.addEventListener("click", ()=>{
    syncServerType("jellyfin");
  });
}

// Initialize server type on page load (default to Emby)
syncServerType("emby");

/*── 2 · Helper ──*/
// Emby authentication function
async function authenticateEmby(url, user, pass) {
  try {
    const res = await fetch(`${url}/Users/AuthenticateByName`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-Emby-Authorization":
          'MediaBrowser Client="StreamBridge", Device="WebHelper", DeviceId="webhelper", Version="1.2.0"'
      },
      body: JSON.stringify({ Username: user, Pw: pass || "" })
    });
    
    if (!res.ok) {
      let errorMessage = "Authentication failed";
      try {
        const errorData = await res.json();
        errorMessage = errorData.Message || errorData.message || `HTTP ${res.status}: ${res.statusText}`;
      } catch {
        errorMessage = `HTTP ${res.status}: ${res.statusText}`;
      }
      throw new Error(errorMessage);
    }
    
    const data = await res.json();
    return data;
  } catch (err) {
    // Re-throw with better context if it's not already our error
    if (err.message && !err.message.includes("HTTP") && !err.message.includes("Authentication")) {
      throw new Error(`Network error: ${err.message}`);
    }
    throw err;
  }
}

// Jellyfin authentication function
async function authenticateJellyfin(url, user, pass) {
  try {
    const res = await fetch(`${url}/Users/authenticatebyname`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json",
        "Authorization":
          'MediaBrowser Client="StreamBridge", Device="WebHelper", DeviceId="webhelper", Version="1.2.0"'
      },
      body: JSON.stringify({ Username: user, Pw: pass || "" })
    });
    
    if (!res.ok) {
      let errorMessage = "Authentication failed";
      try {
        const errorData = await res.json();
        errorMessage = errorData.Message || errorData.message || `HTTP ${res.status}: ${res.statusText}`;
      } catch {
        errorMessage = `HTTP ${res.status}: ${res.statusText}`;
      }
      throw new Error(errorMessage);
    }
    
    const data = await res.json();
    return data;
  } catch (err) {
    // Re-throw with better context if it's not already our error
    if (err.message && !err.message.includes("HTTP") && !err.message.includes("Authentication")) {
      throw new Error(`Network error: ${err.message}`);
    }
    throw err;
  }
}

$("#helper").addEventListener("submit", async e=>{
  e.preventDefault();
  const f=new FormData(e.target),
        urlRaw=f.get("url"),
        user=f.get("user"),
        pass=f.get("pass");
  const btn=$("#helperBtn");
  btn.disabled=true;btn.textContent="Fetching…";

  // Validate and normalize URL
  if(!urlRaw || !urlRaw.trim()) {
    alert("❌ Please enter a server URL.");
    btn.disabled=false;btn.textContent="Get Access Info";
    return;
  }
  
  const url = urlRaw.trim().replace(/\/+$/,"");
  
  // Ensure HTTPS
  if(!url.startsWith("https://")) {
    alert("❌ Please use HTTPS URLs only. Your server must be accessible via HTTPS for this addon to work.");
    btn.disabled=false;btn.textContent="Get Access Info";
    return;
  }
  
  // Basic URL format validation
  try {
    new URL(url);
  } catch {
    alert("❌ Please enter a valid URL (e.g., https://example.com:8096)");
    btn.disabled=false;btn.textContent="Get Access Info";
    return;
  }

  // Get server type from selected server type
  const selectedServerTypeEl = $("#selectedServerType");
  const serverType = selectedServerTypeEl ? selectedServerTypeEl.value : "emby";

  try{
    // Call appropriate authentication function based on server type
    const data = serverType === "jellyfin" 
      ? await authenticateJellyfin(url, user, pass)
      : await authenticateEmby(url, user, pass);

    $("#uid").textContent = data?.User?.Id || "";
    $("#tok").textContent = data?.AccessToken || "";
    $("#helperOut").style.display="block";

    /* autofill config form */
    const cf=$("#cfg");
    // Sync server type to Step 2
    syncServerType(serverType);
    // Autofill form fields
    cf.serverUrl.value   ||= url;
    cf.userId.value      ||= data?.User?.Id||"";
    cf.accessToken.value ||= data?.AccessToken||"";
  }catch(err){
    alert("❌ "+err.message);
  }finally{
    btn.disabled=false;btn.textContent="Get Access Info";
  }
});

/*── 3 · Config ──*/
$("#cfg").addEventListener("submit",e=>{
  e.preventDefault();
  const formData = new FormData(e.target);
  const cfg = {};
  
  // Get server type from selected server type (source of truth) or fallback to hidden input
  const selectedServerTypeEl = $("#selectedServerType");
  const serverTypeFromSelection = selectedServerTypeEl ? selectedServerTypeEl.value : null;
  const serverTypeFromForm = formData.get("serverType");
  cfg.serverType = serverTypeFromSelection || serverTypeFromForm || "emby";
  
  // Validate server type is either 'emby' or 'jellyfin'
  if (cfg.serverType !== "emby" && cfg.serverType !== "jellyfin") {
    cfg.serverType = "emby"; // Default to emby if invalid
  }
  
  // Required fields
  const serverUrlRaw = formData.get("serverUrl");
  cfg.serverUrl = serverUrlRaw ? serverUrlRaw.trim().replace(/\/+$/, "") : "";
  cfg.userId = formData.get("userId");
  cfg.accessToken = formData.get("accessToken");
  
  // Validate required fields
  if (!cfg.serverUrl || !cfg.userId || !cfg.accessToken) {
    alert("❌ Please fill in all required fields (Server URL, User ID, and Access Token).");
    return;
  }
  
  // Validate URL format (HTTPS not required in Step 3)
  try {
    new URL(cfg.serverUrl);
  } catch {
    alert("❌ Please enter a valid URL (e.g., https://example.com:8096 or http://localhost:8096)");
    return;
  }
  
  // New optional fields
  // showServerName: convert checkbox to boolean (checked = true, unchecked = false)
  // FormData.get() returns the value for checked boxes, or null for unchecked
  const showServerNameValue = formData.get("showServerName");
  cfg.showServerName = showServerNameValue !== null && showServerNameValue !== undefined;
  
  // streamName: use provided value or leave empty for auto-detection based on server type
  const streamName = formData.get("streamName");
  if (streamName && streamName.trim()) {
    cfg.streamName = streamName.trim();
  }
  
  // hideStreamTypes: collect all checked values into an array
  const hideStreamTypes = formData.getAll("hideStreamTypes");
  if (hideStreamTypes.length > 0) {
    cfg.hideStreamTypes = hideStreamTypes;
  }

  const cfg64=btoa(unescape(encodeURIComponent(JSON.stringify(cfg))))
                .replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"");

  const httpURL    = `${location.origin}/${cfg64}/manifest.json`;
  const stremioURL = `stremio://${location.host}/${cfg64}/manifest.json`;

  // Create output HTML (URLs are safe - base64 encoded, no XSS risk)
  const urlDisplay = document.createElement('pre');
  urlDisplay.textContent = httpURL;
  
  const copyBtn = document.createElement('button');
  copyBtn.className = 'copy-btn';
  copyBtn.textContent = 'Copy URL';
  copyBtn.onclick = () => {
    navigator.clipboard.writeText(httpURL).then(() => toast('Copied URL'));
  };

  $("#cfgOut").innerHTML = `
    <p><a href="${stremioURL}">➜ Install directly in Stremio</a></p>
    <small>Or copy this URL and add it via <em>Add-ons → Install via URL</em>:</small>
  `;
  $("#cfgOut").appendChild(urlDisplay);
  $("#cfgOut").appendChild(copyBtn);
});
</script>
<script src='https://storage.ko-fi.com/cdn/scripts/overlay-widget.js'></script>
<script>
  kofiWidgetOverlay.draw('harsimranjeetsingh4', {
    'type': 'floating-chat',
    'floating-chat.donateButton.text': 'Support me',
    'floating-chat.donateButton.background-color': '#22c55e',
    'floating-chat.donateButton.text-color': '#fff'
  });
</script>
</body>
</html>
